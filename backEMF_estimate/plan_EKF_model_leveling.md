## 拡張 EKF 設計ロードマップ

（実機の **磁束マップ** φ<sub>d</sub>, φ<sub>q</sub> → I<sub>d</sub>, I<sub>q</sub> を活用）

| フェーズ                            | 目標                                                               | 状態ベクトル例                                                             | モデル／ヤコビアンのポイント                                                                               | 実装タスク                                                                               |
| ------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------- | -------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |
| **0. 現状確認**                     | 既存コードで Rs・ψ<sub>f</sub> 推定の安定動作を再確認                              | **x = \[i\_d, i\_q, R\_s, ψ\_f]**                                   | F, Q は既定値                                                                                    | ✓ 完了                                                                                |
| **1-a. 飽和なしで 「磁束マップ」直接利用**      | d-q 軸**実磁束** φ<sub>d</sub>, φ<sub>q</sub> を状態に追加し、センサ電流との差を使って補正 | **x = \[φ\_d, φ\_q, R\_s]** <br>(i<sub>d</sub>,i<sub>q</sub> は観測のみ) | • 電圧方程式を **φ̇ = v − R\_s i − ω J φ** 形に書き換え <br>• i = **M⁻¹(φ)** をマップ逆変換<br>• F は数値ヤコビアンで OK | 1. マップ逆関数 (φ→i) を LUT + 2D 係数補間で実装<br>2. 数値微分で ∂i/∂φ を計算し F 更新                      |
| **1-b. 飽和ありで 「加法的補正」方式**        | マップ値 φ<sub>d,q</sub><sup>map</sup>(i) を “名目” とし、**Δφ** のみフィルタで推定 | **x = \[i\_d, i\_q, Δφ\_d, Δφ\_q, R\_s]**                           | • φ = φ<sup>map</sup>(i)+Δφ<br>• 電圧式に代入 → 非線形項は Δφ にのみ残る<br>• ヤコビアンは**解析＋補間桶変数**で軽量化         | 1. 既測マップを φ<sup>map</sup>(i) で使用<br>2. 解析 Jacobian は ∂φ<sup>map</sup>/∂i だけ LUT で用意 |
| **2. 温度・熱モデルを組込み**              | 温度 T を状態にし、Rs・ψ<sub>f</sub>・マップ補正を **T 依存** に                    | **x = \[i\_d, i\_q, T] (+他)**                                       | • Ṫ = (P\_loss − (T − T\_amb)/R<sub>θ</sub>)/C<br>• R\_s(T), ψ\_f(T), φ<sup>map</sup>(T)    | 1. 熱パラメータ R<sub>θ</sub>, C を同定<br>2. ヤコビアンに ∂R\_s/∂T 等を追加                           |
| **3. 機械側拡張 (ω, τ<sub>L</sub>)** | 角速度センサを外し、**電気角速度**と**負荷トルク**を EKF に含める                          | **x = \[θ\_e, ω\_e, i\_d, i\_q, …]**                                | • 機械方程式: ω̇ = (T\_e − τ\_L)/J <br>• θ̇ = ω\_e/2p                                             | 1. 慣性 J、負荷モデル τ<sub>L</sub> を設定<br>2. 観測に θ\_e（例: エンコーダ） or 滑差を使う                   |
| **4. 高周波注入併用**                  | ゼロ速域での位相推定精度を上げる                                                 | x に **HF 電流応答** パラメータを追加                                            | • HFI モデルを線形化して F、H に統合                                                                      | 1. 既存 HFI コードと統合<br>2. 同期座標系の切替えに注意                                                 |

### プロセス雑音 Q の調整指針

* **確信があるパラメータ** → 小さめ (10⁻⁸〜10⁻¹²)
* **ゆっくり変わるパラメータ (温度由来)** → 10⁻⁶〜10⁻⁸
* **速く変動し得る量 (負荷トルク、HF パラメータ)** → 10⁻³〜10⁻⁵

→ 各フェーズで「推定が遅れる／振動する」を見ながら対角成分を 10×～0.1× でスイープすると収束点が見つけやすい。

### 実装ステップ（フェーズ 1-a or 1-b 推奨）

1. **LUT モジュール**

   * 測定マップ (φ or i) を 2D グリッドで保存（SciPy `RegularGridInterpolator` や自家製線形補間）。
   * **逆変換**が必要なら `scipy.optimize.root` を初期値フィードフォワード＋1〜2 回 Newton で十分高速。
2. **ヤコビアン計算**

   * 解析式が複雑なら **前進差分**：

     $$
       \frac{\partial f}{\partial x_i}\approx\frac{f(x+ε e_i)-f(x)}{ε}
     $$

     ε≈10⁻⁶ が実用。PMSM なら 100 µs サイクルでも余裕。
3. **テストリグ**

   * オフラインで **“実機電圧波形＋測定電流”** を再生し、推定収束と誤差分布をログ。
   * Python で動作確認後、C/C++ にトランスパイル (`numba`, `cython`, もしくは Simulink C-codegen)。
4. **オンライン比較**

   * 既存インバータ DSP 上で並列実行（旧オブザーバ vs EKF）。
   * 温度ステップ試験／高トルク過渡で双方の誤差を比較。
5. **調整ループ**

   * Q,R→ゲイン調整
   * LUT メッシュ粗さ→計算負荷／精度トレードオフ
   * 状態追加 or 削除→発散・追従性チェック

---

### 次に決めたいこと

* フェーズ 1-a（φ 状態）と 1-b（Δφ 補正）のどちらで始めるか

  * **1-a**: 実装はシンプル、逆関数解くので LUT がやや重い
  * **1-b**: LUT 軽量、既存電流状態を活かせるが数式が増える
* 温度を **推定** するか、別サーミスタで **観測入力** として与えるか
* 実行環境（MCU/DSP）と許容ステップ時間

> このあたりを教えていただければ、具体的なコードスケッチと数値例（F・Q 行列初期値）を提案します。
