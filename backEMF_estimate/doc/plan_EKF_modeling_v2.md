### ゴールの再確認

* **やりたいこと** : 実機で測った φ<sub>d</sub>, φ<sub>q</sub> マップを利用して **リアルタイムに磁束を推定** →
  推定磁束から **電磁トルク**

  $$
    T_e = \tfrac32\,p\bigl(\, \phi_d\,i_q-\phi_q\,i_d \bigr)
  $$

  を計算し、温度や飽和で変動するトルク定数を補償する
* **不要なもの** : 機械角度 θ や速度 ω の推定（外部エンコーダや位置センサで得られると仮定）

---

## 1. 状態ベクトルとモデルの選択肢

| 選択肢                         | 状態ベクトル **x**                                                        | 長所                                | 短所                    |
| --------------------------- | ------------------------------------------------------------------- | --------------------------------- | --------------------- |
| **A. φ 直接推定**               | $[\,\phi_d,\;\phi_q,\;R_s\,]^{\!\mathsf T}$                         | *式が素直*。逆マップ不要                     | φ→i 変換に **逆 LUT** が要る |
| **B. Δφ（補正量）推定**            | $[\,i_d,\;i_q,\;\Delta\phi_d,\;\Delta\phi_q,\;R_s\,]^{\!\mathsf T}$ | *電流を状態に含むので逆 LUT 不要*。既存コードを拡張しやすい | 状態次元↑、F が少し複雑         |
| **C. スケール係数 k<sub>φ</sub>** | $[\,i_d,\;i_q,\;k_\phi,\;R_s\,]^{\!\mathsf T}$\*                    | 単一パラメータで温度依存を表現可能                 | 飽和のような**軸別非線形**は表せない  |

\* φ<sub>d,q</sub> = k<sub>φ</sub>·φ<sup>map</sup><sub>d,q</sub>(i)

> **推奨スタート** : **B. Δφ 方式**
> 　*既存 EKF のフレームを崩さず、測定マップをそのまま使用できる*

---

## 2. Δφ 方式の連続時間方程式

1. **名目磁束**（測定マップ）

   $$
     \phi_d^{\text{map}} = f_d(i_d,i_q),\qquad
     \phi_q^{\text{map}} = f_q(i_d,i_q)
   $$

2. **真の磁束**

   $$
     \phi_d = \phi_d^{\text{map}} + \Delta\phi_d,\quad
     \phi_q = \phi_q^{\text{map}} + \Delta\phi_q
   $$

3. **電圧方程式** (dq 座標, ω<sub>e</sub> は入力)

$$
\begin{aligned}
\dot{\phi}_d &= v_d - R_s\,i_d + \omega_e\,\phi_q,\\
\dot{\phi}_q &= v_q - R_s\,i_q - \omega_e\,\phi_d.
\end{aligned}
$$

4. **Δφ のダイナミクス**

   $$
     \dot{\Delta\phi}_d = \dot{\phi}_d - 
       \frac{\partial \phi_d^{\text{map}}}{\partial i_d}\dot{i}_d -
       \frac{\partial \phi_d^{\text{map}}}{\partial i_q}\dot{i}_q
   $$

   同様に Δφ<sub>q</sub>。
   解析式は複雑なので **「0 + プロセス雑音」** ＝ランダムウォークで十分
   → $\dot{\Delta\phi}_{d,q}=w_{d,q}$.

5. **電流ダイナミクス** (既存と同じ)

   $$
   \begin{aligned}
   \dot i_d &= \frac1{L_d}(-R_s i_d + \omega_e L_q i_q + v_d),\\
   \dot i_q &= \frac1{L_q}(-R_s i_q - \omega_e L_d i_d - \omega_e \psi_f + v_q).
   \end{aligned}
   $$

   ここで ψ<sub>f</sub> は**温度で変わる定数**なら状態に入れても良いが，
   「マップで吸収」と割り切れば除外可。

---

## 3. EKF の実装ポイント

### 3.1 状態・観測

```text
x = [ i_d, i_q, Δφ_d, Δφ_q, R_s ]ᵀ      (nx = 5)
z = [ i_d_obs, i_q_obs ]ᵀ               (nz = 2)
u = [ v_d, v_q, ω_e ]ᵀ                  (nu = 3)
```

* 観測行列 `H = [[1,0,0,0,0],[0,1,0,0,0]]`
* 名目磁束マップ `φ_map(i)` は 2D LUT

### 3.2 予測ステップ

```python
# unpack
i_d, i_q, dphi_d, dphi_q, R_s = x_hat
phi_d_map = phi_d_lut(i_d, i_q)
phi_q_map = phi_q_lut(i_d, i_q)
phi_d = phi_d_map + dphi_d
phi_q = phi_q_map + dphi_q
# state derivatives
di_d = ( -R_s*i_d + w_e*L_q*i_q + v_d ) / L_d
di_q = ( -R_s*i_q - w_e*L_d*i_d - w_e*psi_f + v_q ) / L_q
# Δφ random walk → derivative = 0
dx = np.array([di_d, di_q, 0.0, 0.0, 0.0])
x_hat += dx * dt
# Linearise f for F (ヤコビアン)
F = numerical_jacobian(f, x_hat, u)  # 5×5
P = F @ P @ F.T + Q
```

* **数値ヤコビアン**で十分：`eps=1e-6` で前進差分
* LUT 逆導関数は不要

### 3.3 Q 行列の初期値例

| 状態                             | 推奨 σ² (例)                           |
| ------------------------------ | ----------------------------------- |
| i<sub>d</sub>, i<sub>q</sub>   | 1 e-6                               |
| Δφ<sub>d</sub>, Δφ<sub>q</sub> | 1 e-8（温度・飽和で数秒かけて 0.01 Wb 変動ならこの程度） |
| R<sub>s</sub>                  | 1 e-9                               |

### 3.4 トルク補償の使い方

1. サーボループで必要トルク $T_\text{ref}$ を計算
2. 推定磁束 φ̂ と目標トルクから **q 軸電流指令**

   $$
     i_{q,\text{ref}} = \frac{2}{3\,p}\,
        \frac{T_\text{ref} + 1.5\,p\,\phi_q\,i_d}
             {\phi_d}
   $$
3. d 軸電流指令は効率最適値 (MPP) などを採用
4. 電流制御器へ

---

## 4. 次の具体的タスク

| # | To-do                                                                          | 参考ヒント                         |
| - | ------------------------------------------------------------------------------ | ----------------------------- |
| ① | **LUT 実装**: `RegularGridInterpolator` で φ<sup>map</sup><sub>d,q</sub>(i) を読み出し | 2 × (100×100) グリッドでも 10 µs 以下 |
| ② | 数値ヤコビアン関数 `numerical_jacobian(f,x,u)` を作成                                      | ループで nx+1 回 `f()` 呼び出すだけ      |
| ③ | 5 状態版 EKF を Python でシミュレーション                                                   | センサノイズ・温度上昇を与えて収束確認           |
| ④ | **Q,R チューニング**: 対角成分を ×10 ↔ ÷10 でグリッドサーチ                                       | “最速安定” を目視で選択                 |
| ⑤ | C/C++ への移植（必要なら）                                                               | Numpy 部分は手書き行列演算に置換           |
| ⑥ | 実機テスト: 温度サイクルと高トルク過渡でトルク誤差ログ                                                   | 補償 ON/OFF 比較                  |

---

## 5. 角度推定が不要なことで楽になる点

* **状態次元削減**：θ, ω を入れないので F が小さく、計算量↓
* **速度誤差起因の不整合**が無い（ω\_e は測定・外部推定で与える）
* クロス結合 $(\omega_e \phi_q,\ -\omega_e \phi_d)$ は依然モデルに現れるので
  **ω\_e の時定数誤差**が EKF の安定性に影響 → 必要なら ω\_e を入力フィルタで平滑化

---

### もし **ψ\_f** 温度依存を別途補正したい場合

* 状態に **k\_ψ** を追加して $\psi_f = k_\psi \psi_{f,25°C}$ とする
* 電圧式の $-\omega_e \psi_f$ 項だけヤコビアン 1 個増えるだけの軽微な変更

---

**これで「磁束推定 → トルク補償」の基本構成が定まります。**
実装を始める際に「LUT 形式」や「数値ヤコビアンの実コード」など具体的なコード例が必要でしたら、また声をかけてください。
