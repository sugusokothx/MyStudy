提供されたスケルトンコードにおける電流（$i$）の予測・更新ステップは、EKF（拡張カルマンフィルタ）の状態量である**電流 $i\_d$ と $i\_q$** を直接推定することで行われます。コードの以下の部分が電流の予測・更新に関連しています。

1.  **状態ベクトルの定義**:
    EKFの状態ベクトル \`x\` の最初の2つの要素は、電流 $i\_d$ と $i\_q$ です。これらは、EKFによって直接推定される状態量です。
    ``` python
    class DeltaPhiEKF:
        """
        状態: x = [ i_d, i_q, dphi_d, dphi_q, R_s ]^T
        観測: z = [ i_d_obs, i_q_obs ]^T
        """
        # ...
        self.x_hat = np.zeros((5, 1)) # 1番目と2番目の要素がi_d, i_qの推定値
        # ...
    ```
2.  **状態方程式（連続時間モデル）**:
    \`\_f\_continuous\` メソッドでは、電流 $i\_d$ と $i\_q$ の時間微分（\`di\_d\` および \`di\_q\`）を計算するための状態方程式が定義されています。この方程式は、推定された状態量（電流 $i\_d, i\_q$、磁束偏差 $dphi\_d, dphi\_q$、抵抗 $R\_s$）、入力（電圧 $v\_d, v\_q$、角速度 $\omega\_e$）、およびモータパラメータ（インダクタンス $L\_d, L\_q$、名目磁石鎖交磁束 $\_psi\_f\_nom$）に基づいています。
    ``` python
    def _f_continuous(selfself, x, u):
        i_d, i_q, dphi_d, dphi_q, R_s = x.flatten()
        v_d, v_q, w_e = u

        # マップ + Δφ
        phi_d = float(phi_d_lut([i_d, i_q])) + dphi_d
        phi_q = float(phi_q_lut([i_d, i_q])) + dphi_q

        # 電流ダイナミクス (線形仮定)
        di_d = ( -R_s * i_d + w_e * self.Lq * i_q + v_d ) / self.Ld
        di_q = ( -R_s * i_q - w_e * self.Ld * i_d - w_e * self._psi_f_nom + v_q ) / self.Lq

        # Δφ と R_s はランダムウォーク
        return np.array([di_d, di_q, 0.0, 0.0, 0.0]) # 1番目と2番目の要素がi_d, i_qの時間微分
    ```
    ここで使用されている電流ダイナミクスは、インダクタンス $L\_d, L\_q$ が定数であるという線形仮定に基づいています。この状態方程式は、電流の予測ステップの基礎となります。
3.  **予測ステップ**:
    \`predict\` メソッドでは、\`\_f\_continuous\` で定義された連続時間の状態方程式を離散化（オイラー法を使用）して、状態ベクトル \`self.x\_hat\` の予測値が計算されます。電流 $i\_d$ と $i\_q$ の予測値は、この状態方程式の時間微分 \`di\_d\` および \`di\_q\` に時間刻み \`dt\` を乗じて、前回の推定値に加算することで得られます。
    ``` python
    def predict(self, u):
        # dx/dt & オイラー離散化
        f_val = self._f_continuous(self.x_hat.flatten(), u)
        self.x_hat = self.x_hat + f_val.reshape(-1, 1) * self.dt

        # ヤコビアン F ≈ ∂f/∂x
        F = numerical_jacobian(self._f_continuous, self.x_hat.flatten(), u)

        F_k = np.eye(5) + F * self.dt
        self.P = F_k @ self.P @ F_k.T + self.Q
        # ...
    ```
    予測ステップでは、ヤコビアン行列 \`F\` も計算され、状態の共分散 \`P\` の予測に使用されます。これは、次の更新ステップでカルマンゲインを計算するために重要です。
4.  **観測モデル**:
    観測ベクトル \`z\` は、電流の観測値 \`\[ i\_d\_obs, i\_q\_obs \]^T\` で構成されています。観測行列 \`H\` は、状態ベクトルから電流 $i\_d$ と $i\_q$ を取り出すように定義されています。
    ``` python
    self.H = np.array([]) # 状態ベクトルの1,2番目（i_d, i_q）を観測
    ```
    電流は直接観測可能な状態量であり、これがEKFの更新ステップの主要な情報源となります。
5.  **更新ステップ**:
    \`update\` メソッドがEKFの更新ステップを実行します。ここで、実際の電流観測値 \`z\` と、予測ステップで計算された状態の予測値 \`self.x\_hat\` に基づいた予測観測値（\`self.H @ self.x\_hat\`、これは予測された $i\_d$ と $i\_q$ に等しい）との間の誤差（\`y = z - self.H @ self.x\_hat\`）が計算されます。
    ``` python
    def update(self, z):
        # ...
        y = z - self.H @ self.x_hat # 観測誤差
        self.x_hat += K @ y # 状態予測値の補正
        # ...
    ```
    EKFは、この観測誤差 \`y\` とカルマンゲイン \`K\` を用いて、状態ベクトルの予測値 \`self.x\_hat\` を補正します。カルマンゲイン \`K\` は、予測ステップで計算された共分散 \`P\`、観測モデル \`H\`、観測ノイズ共分散 \`R\` に基づいて計算され、観測誤差を各状態量にどのように割り振るかを決定します。電流 $i\_d$ と $i\_q$ は直接観測されるため、観測誤差 \`y\` はこれらの状態量の推定値に最も強くフィードバックされます。
6.  **アクセサプロパティ**:
    \`@property\` デコレータで定義されている \`i\_d\` と \`i\_q\` は、更新ステップを経て補正された状態ベクトル \`self.x\_hat\` から、現在の推定電流値を提供します。
    ``` python
    @property
    def i_d(self):
        return self.x_hat
    @property
    def i_q(self):
        return self.x_hat
    ```

**電流の予測・更新メカニズムのまとめ**:

*   電流 $i\_d$ と $i\_q$ は、EKFの状態量として直接推定されます。
*   予測ステップでは、モータの電圧方程式に基づいた電流ダイナミクスを用いて、電流の予測値が計算されます。このモデルは線形仮定に基づいています。
*   更新ステップでは、実際の電流観測値と予測された電流値の間の誤差が計算されます。
*   この観測誤差は、カルマンゲインを通じて電流 $i\_d$ と $i\_q$ の推定値にフィードバックされ、予測値が補正されてより正確な電流の推定値が得られます。

このコードは、電流をEKFの主要な推定状態として扱うことで、高精度な電流推定を実現し、それが磁束マップを用いた磁束推定の基礎となるフェーズ1-bのアプローチを反映しています。

ご不明な点がございましたら、お気軽に追加で質問してください。