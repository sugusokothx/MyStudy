ありがとうございます。温度依存の磁束補正を取り入れたモータモデルと、それに基づくEKF追従シミュレーションの構造設計について調査します。

EKF は観測に \[id, iq] を用い、モータモデルは温度テーブルに従って Rs, L, ψf を変化させながら、同じ VdVq 指令に対して IdIq がどう変わるかを再現し、それを EKF で追従・推定する構造です。コントローラは固定の VdVq を出力するものとして設計します。

この要件に沿って：

* 温度依存のモータパラメータ変化のシナリオ例（または補正係数の設計例）
* EKF 実装との統合例（異なる更新周期の扱い含む）
* Pythonなどでの模擬シミュレーション構成例
  を整理してご提案します。

しばらくお待ちください。


# 温度依存モータモデルとEKFによるパラメータ推定シミュレーション設計

## はじめに

電動機の特性は温度によって変化し、特に巻線抵抗やインダクタンス、永久磁石の磁束といったパラメータは温度上昇に伴い変動します。モータ制御システムの高性能化のためには、こうしたパラメータ変動を適切に推定・追従することが重要です。本レポートでは、温度変化に応じてモータの磁束\$\psi\_f\$・インダクタンス\$L\$・抵抗\$R\_s\$が変化するモータモデルを組み込み、拡張カルマンフィルタ（EKF）によってそれらのパラメータをオンライン推定するシミュレーション構成について検討します。要求仕様として、EKFは電流観測値として\$d\$軸・\$q\$軸電流（\$i\_d, i\_q\$）を利用し、モータモデルは電圧指令\$V\_d, V\_q\$と回転速度\$\omega\$を入力として電流応答を生成します。また温度は時間とともに既知の関数あるいはテーブルに従い変化し、その都度モータパラメータに反映されます。制御器から出力される電圧指令\$V\_d, V\_q\$は既知の一定波形と仮定し、モータ側の状態変化のみによって電流が変動するものとします。サンプリング周期は比較的長い（例：約5ms）とし、この枠組みでEKFが温度に起因するパラメータ変動へ追従できるかを評価する構造を目指します。本稿では以下の観点について整理します：

* 温度からモータパラメータ（\$R\_s, L, \psi\_f\$）への変換テーブル設計方法の例
* モータモデルとEKFを統合する際の構成案（特にモータモデルの高速応答とEKF更新周期の異なる場合の取り扱い）
* Pythonを用いたシミュレーション構成例（クラス設計、データフロー、可視化方法など）およびコードスケルトン

## 温度によって変化するモータモデル

本シミュレーションで扱うモータは永久磁石同期モータ（PMSM）を想定し、三相交流を\$d\$-\$q\$座標系に変換した電圧\$V\_d, V\_q\$と回転速度\$\omega\$を入力とするモデルを用います。状態として\$d\$軸電流\$i\_d\$と\$q\$軸電流\$i\_q\$を持ち、出力（観測可能量）も同じく\$i\_d, i\_q\$です。PMSMの電気系の状態方程式は以下のように記述できます（サンプルとして表します）：

* \$d\$軸電流の微分方程式：
  $\frac{d i_d}{dt} = \frac{1}{L_d}\Big(V_d - R_s\,i_d + \omega\,L_q\,i_q\Big)$

* \$q\$軸電流の微分方程式：
  $\frac{d i_q}{dt} = \frac{1}{L_q}\Big(V_q - R_s\,i_q - \omega\,(L_d\,i_d + \psi_f)\Big)$

ここで\$R\_s\$はステータ巻線抵抗、\$L\_d, L\_q\$は各軸のインダクタンス、\$\psi\_f\$は永久磁石の磁束（主磁束）を表します。今回は簡略化のためモータを表列子型（表面磁石型）のPMSMとみなし、\$d\$軸と\$q\$軸のインダクタンスは等しい（\$L\_d = L\_q = L\$）と仮定します。その場合上式は\$L\_d=L\_q=L\$を代入して簡略化できます。モータモデルは入力として電圧指令\$V\_d, V\_q\$と回転速度\$\omega\$を受け取り、内部でこれらの方程式を数値積分することで電流応答\$i\_d(t), i\_q(t)\$を計算します。**動的応答**も含めるため、オイラー法やRunge-Kutta法などの数値積分手法を用いて微分方程式を離散時間ステップで解きます。例えばサンプリング周期を\$\Delta t = 5\text{ms}\$とする場合、各刻みで上記微分方程式を積分し\$i\_d, i\_q\$の値を更新します。

本モデルの特徴は、パラメータ\$R\_s, L, \psi\_f\$がモータ温度に依存して変化する点です。一般に、**巻線抵抗**\$R\_s\$は温度上昇で増加し、**永久磁石磁束**\$\psi\_f\$（例えばNdFeB系磁石の場合）は温度上昇で減少します。またインダクタンス\$L\$については温度による材料透磁率の変化や巻線抵抗増加に伴う損失で若干変化する可能性がありますが、ここでは簡単のため変化率は小さいものとします（微小な減少傾向程度を仮定）。このモータモデルでは、時刻\$t\$におけるモータ温度\$T(t)\$に応じてそれぞれのパラメータを更新し、直近のパラメータ値で微分方程式を解き進めます。すなわち**温度依存パラメータ**として、\$R\_s = R\_s(T)\$、\$L = L(T)\$、\$\psi\_f = \psi\_f(T)\$と設定します。

### 温度からパラメータへの変換テーブル設計

温度からパラメータ値への変換は、**関数式による算出**または**離散的なテーブルによる補間**によって実現できます。設計者は事前実験やデータシートから、いくつかの代表温度におけるパラメータ値を取得し、テーブルとして保持する方法を考えています。例えば巻線抵抗\$R\_s\$であれば銅線の温度係数が既知であり、約\$\alpha \approx 0.0039\$/°C（20°C付近）と知られています。この係数を用いれば**基準温度**（例えば20°C）からの相対変化として以下で算出できます：

* \$R\_s(T) = R\_{s0},{1 + \alpha ,(T - T\_0)}\$  （\$T\_0\$は基準温度、\$R\_{s0}\$はそのときの抵抗）

永久磁石の磁束\$\psi\_f\$についても、磁石材料の残留磁気の温度係数を用いて近似できます。例えばネオジム磁石の場合、残留磁束密度の温度係数は約\$-0.1%/\text{°C}\$程度（すなわち1°C上昇で約0.1%磁束が減少）とされています。インダクタンス\$L\$は磁気回路の温度特性によりますが、大きな変化はないと仮定するか、ごく微小な減少を線形近似することができます。

**テーブル設計の方法**としては、代表値をいくつかの温度点で設定し線形補間するのが簡便です。以下に例として、20°Cから100°Cまでの温度とパラメータの対応テーブル例を示します（数値は仮のものです）：

| 温度 \[°C] | 巻線抵抗 \$R\_s\$ \[Ω] | インダクタンス \$L\$ \[H] | 磁石磁束 \$\psi\_f\$ \[Wb] |
| -------- | ------------------ | ------------------ | ---------------------- |
| 20       | 0.50               | 0.0100             | 0.100                  |
| 60       | 0.58               | 0.0098             | 0.095                  |
| 100      | 0.65               | 0.0095             | 0.090                  |

上記では20°Cでの\$R\_s\$を0.50Ωとし、温度上昇に伴い直線的に0.65Ω程度まで増加する例です（おおよそ0.5Ωから30%増加で、銅の温度係数0.39%/°Cによる80°C上昇分と一致します）。\$\psi\_f\$は20°Cで0.100 Wbから100°Cで0.090 Wbへ減少させています（約10%減少、1°Cあたり0.125%減少に相当し、ネオジム磁石の係数範囲内）。インダクタンス\$L\$は0.01 Hから若干減少する設定です。**実際のテーブル設計**では、モータごとのデータシート値や実測補正値に基づいてより詳細な離散点を用意し、線形またはスプライン補間することで任意温度でのパラメータ値を得ることになります。また、温度からパラメータへの関数が明確にわかっている場合は直接式を実装しても構いません。いずれにせよ、シミュレーション中は各時刻の温度に応じて\$R\_s, L, \psi\_f\$を更新し、それを用いて電流応答を計算します。

**実装上の工夫:** Pythonでこのテーブルを扱う場合、温度配列と各パラメータ配列を用意し、`numpy.interp`による線形補間で\$T(t)\$からパラメータを取得する方法があります。または単純に温度が離散ステップで決まっているなら辞書やリストで引き当ててもよいでしょう。例えば以下のようなコードスニペットでテーブルを扱えます：

```python
# 温度 -> パラメータ変換の例実装
temp_table = [20, 60, 100]  # 温度の離散点
Rs_table = [0.50, 0.58, 0.65]
L_table  = [0.0100, 0.0098, 0.0095]
psi_table= [0.100, 0.095, 0.090]

def get_params_from_temp(T):
    Rs = np.interp(T, temp_table, Rs_table)
    L  = np.interp(T, temp_table, L_table)
    psi= np.interp(T, temp_table, psi_table)
    return Rs, L, psi
```

上記`get_params_from_temp`関数を使えば、現在温度\$T\$におけるパラメータ値を計算できます。この関数をモータモデル内で呼び出し、都度\$R\_s, L, \psi\_f\$を更新します。

## EKFによるパラメータ推定とモデル統合

温度により変化するパラメータを推定するため、**拡張カルマンフィルタ（EKF）**を導入します。EKFは非線形システムに対する状態推定手法であり、本ケースでは「状態」に推定対象のモータパラメータを含めることでオンラインパラメータ同定を実現します。すなわち、EKFの状態ベクトルに巻線抵抗\$R\_s\$・インダクタンス\$L\$・磁束\$\psi\_f\$を含め、それらを**ゆっくり変化する状態**（定数に近いが徐々に変動し得る値）としてモデル化します。さらに、モータ電流そのもの（\$i\_d, i\_q\$）も状態ベクトルに含めます。結果、推定対象の状態ベクトルの一例は以下のようになります。

* **状態ベクトル** \$x = \[,i\_d,; i\_q,; R\_s,; L,; \psi\_f,]^T\$

ここで\$i\_d, i\_q\$は電気系の動的状態、\$R\_s, L, \psi\_f\$は定数パラメータですが、EKFではこれらも状態として拡張しています。EKFは観測として実測電流$\[i\_d, i\_q]\$を用いるため、上記状態のうち\$i\_d, i\_q\$がセンサ計測値に対応します。残りの3つの状態（パラメータ）は観測できない未知量であり、これらを推定することが目的です。

**システムモデル:** EKF設計のためには状態方程式（システムモデル）と観測方程式（出力モデル）を定義します。本ケースの連続時間モデルは前述のPMSMの微分方程式となりますが、EKF実装の都合上**離散時間近似**を用います。サンプリング周期\$\Delta t\$ごとに状態を更新する離散モデルを構築しましょう。例えばオイラー近似を用いれば、離散系状態方程式は：

$$
x_{k+1} = f(x_k, u_k) + w_k
$$

ただし\$k\$は離散時間インデックス、\$u\_k = \[V\_d(k), V\_q(k), \omega(k)]\$は入力（電圧指令と回転速度）で、\$w\_k\$はプロセスノイズ（モデル不確かさやパラメータ変動のランダム要素）です。具体的な更新則は以下のようになります：

* \$i\_d\[k+1] = i\_d\[k] + \Delta t ,\frac{1}{L\[k]}\Big(V\_{d}\[k] - R\_s\[k]; i\_d\[k] + \omega\[k],L\[k];i\_q\[k]\Big)\$
* \$i\_q\[k+1] = i\_q\[k] + \Delta t ,\frac{1}{L\[k]}\Big(V\_{q}\[k] - R\_s\[k]; i\_q\[k] - \omega\[k],(L\[k];i\_d\[k] + \psi\_f\[k])\Big)\$
* \$R\_s\[k+1] = R\_s\[k] + w\_{R}\[k]\$
* \$L\[k+1]   = L\[k]   + w\_{L}\[k]\$
* \$\psi\_f\[k+1] = \psi\_f\[k] + w\_{\psi}\[k]\$

ここではパラメータ\$R\_s, L, \psi\_f\$は真のシステムでは温度関数に従って決まりますが、EKFのモデル上ではそれを**未知ゆっくり変動パラメータ**とみなし、状態に含めた上でプロセスノイズ\$w\_R, w\_L, w\_{\psi}\$を与えてわずかに変化し得るようにしています。極端にいえば真の変化が無ければ\$w\$は0でパラメータは一定のはずですが、温度上昇に伴う変化を追従できるよう小さなノイズを与えて**ランダムウォーク**モデルを許容する形です。この設定により、EKFはパラメータを定数ではなく動的な状態として逐次推定できます。一般に、環境温度変化は電気的応答より十分遅いため、\$w\_R, w\_L, w\_{\psi}\$の標準偏差は非常に小さく設定されます（つまりパラメータは急には変わらないとの事前知識を織り込む）。

**観測モデル:** 観測方程式はシンプルで、センサで得られるのは電流$\[i\_d, i\_q]\$ですから、

$$
y_k = 
\begin{bmatrix} i_{d}[k] \\ i_{q}[k] \end{bmatrix}
+ v_k
$$

となります（\$v\_k\$は観測ノイズ）。これは状態ベクトルから見れば、\$h(x\_k) = \[i\_d,; i\_q]^T\$という射影であり、観測行列で書けば\$H = \begin{bmatrix}1&0&0&0&0\\\[3pt]0&1&0&0&0\end{bmatrix}\$（状態の第1,2成分を取り出す）です。従ってEKFの**予測**ステップでは上記の状態遷移\$f(x,u)\$を用いて状態と共分散を予測し、**更新**ステップでは観測\$y\_k\$と予測値\$\hat y\_k = \[\hat{i}\_d, \hat{i}\_q]^T\$のズレから状態を修正します。

EKF更新に必要なヤコビ行列について述べます。非線形システムなので、カルマンゲイン計算には状態方程式\$f\$および観測関数\$h\$のヤコビアンが必要です。観測関数\$h\$は単に$\[i\_d, i\_q]\$を抜き出すだけなので、そのヤコビアンは上記\$H\$行列となります。一方、遷移関数\$f\$のヤコビアン\$F = \frac{\partial f}{\partial x}\$は状態を微小変化させたときの次時刻状態変化であり、電流方程式の右辺を各状態成分で偏微分して求めます。例えば簡略化のため\$L\_d=L\_q=L\$の場合、\$F\$の主なブロックは次のようになります（\$5\times5\$行列）：

* \$\partial \dot{i}\_d / \partial i\_d = -\frac{R\_s}{L}\$ 、 \$\partial \dot{i}\_d / \partial i\_q = \frac{\omega L}{L} = \omega\$
* \$\partial \dot{i}\_d / \partial R\_s = -\frac{i\_d}{L}\$ 、 \$\partial \dot{i}\_d / \partial L = -\frac{1}{L^2}(V\_d - R\_s i\_d + \omega L i\_q)\$ （※実際には\$L\$で微分すると式がやや複雑ですが、数値的に計算してもよいでしょう）
* \$\partial \dot{i}\_q / \partial i\_d = -\frac{\omega L}{L} - \frac{\omega \psi\_f}{L}\$ （ただし\$L\$一定と仮定すると\$-\omega\$）、\$\partial \dot{i}\_q / \partial i\_q = -\frac{R\_s}{L}\$
* \$\partial \dot{i}\_q / \partial R\_s = -\frac{i\_q}{L}\$ 、 \$\partial \dot{i}\_q / \partial L = -\frac{1}{L^2}(V\_q - R\_s i\_q - \omega(L i\_d + \psi\_f))\$ 、\$\partial \dot{i}\_q / \partial \psi\_f = -\frac{\omega}{L}\$
* パラメータ部分の微分 \$\partial R\_s\[k+1]/\partial R\_s\[k] = 1\$ （他の状態には依存しない定数項のため）、同様に\$\partial L\[k+1]/\partial L\[k]=1\$、\$\partial \psi\_f\[k+1]/\partial \psi\_f\[k]=1\$。パラメータから電流へのクロス偏微分は0（このモデル上はパラメータに独立のノイズモデルとしたため）。

以上から、\$F\$行列および\$H\$行列を用いてEKFアルゴリズムを構築します。**EKFアルゴリズム**自体は標準的なもので、以下の手順を繰り返します：

1. **予測ステップ（時間更新）:** 直前の状態推定\$\hat{x}*{k}\$とパラメータ推定値を用いて、システムモデル\$f\$を適用し\$\hat{x}*{k+1|k} = f(\hat{x}\_k, u\_k)\$を計算（ここで温度依存パラメータも\$\hat{x}*k\$内の値を用いる）。同時にヤコビアン\$F\_k = \frac{\partial f}{\partial x}\big|*{\hat{x}*k}\$を求め、誤差共分散を予測\$P*{k+1|k} = F\_k,P\_k,F\_k^T + Q\$。ここで\$Q\$はプロセスノイズ共分散行列で、パラメータ部分に小さな値を持つ対角行列とします。
2. **更新ステップ（観測更新）:** 実測の電流値\$y\_{k+1} = \[i\_d^{\text{(meas)}},; i\_q^{\text{(meas)}}]^T\$を取得し、予測出力\$\hat{y}*{k+1|k} = h(\hat{x}*{k+1|k}) = \[\hat{i}*d,; \hat{i}*q]^T\$を計算。残差\$e*{k+1} = y*{k+1} - \hat{y}*{k+1|k}\$を求める。観測モデルのヤコビアンは\$H\$（定数行列）です。カルマンゲイン\$K*{k+1} = P\_{k+1|k},H^T,(H,P\_{k+1|k},H^T + R)^{-1}\$を計算（\$R\$は観測ノイズ共分散行列）。そして状態推定を更新\$\hat{x}*{k+1} = \hat{x}*{k+1|k} + K\_{k+1},e\_{k+1}\$、共分散も更新\$P\_{k+1} = (I - K\_{k+1}H),P\_{k+1|k}\$。

このようにして、EKFは各サンプル時刻で電流観測とモデル予測を突き合わせ、状態であるパラメータ推定値を逐次修正していきます。特に、温度上昇などによる\$R\_s, \psi\_f\$の変化は電流応答にじわじわと反映されるため、EKFはそれを検知してパラメータ値を補正していくことになります。

### 異なる更新周期の扱い

制御システムでは、モータ電気系の内部演算は高速だがセンサ取得は遅い、といった**異なる時間スケール**を扱うことがよくあります。本シミュレーションでも、例えばモータモデル内部の微分方程式を数値的に安定させるためにサンプリングより細かい刻みで計算し、5msごとにEKFの更新を行う構成が考えられます。ここではそのアプローチについて述べます。

* **モータモデルの内部ステップ:** EKFの更新間隔（5ms）より短い内部ステップ\$\Delta t\_{\text{inner}}\$を設定し、例えば1msごとに5回の内部積分を行って電流を更新し続けます。これにより、モータの電気時定数が短い場合でも数値積分の精度を保てます。
* **EKFの予測ステップ:** EKF側では5msごとにまとめて予測を行う実装も可能ですが、より厳密には内部ステップごとに**高速でEKFの予測部分のみ**を回し、観測更新は5msに1回行う方法があります。例えば内部1ms刻みで5回モータを進める間、その都度EKF状態も予測計算だけ進めておき、5ms時点での予測値\$\hat{x}\_{k+1|k}\$を得ます。そして5ms時点で観測が来たときに一度だけ更新ステップを適用します。
* **実装の簡略化:** 上記を簡略化する場合、モータモデルとEKFの両方を5msの固定ステップで回す方法もあります。この場合、5msという刻みでオイラー解法を用いてもシミュレーションが許容できる範囲であれば、モータ方程式を5msステップで直接積分し、同じタイミングでEKF予測・更新を行います。この手法は実装が容易ですが、厳密性は多少落ちるため、必要に応じてステップサイズを調整します。

本ケースでは\*\*サンプリング周期自体が比較的遅い（5ms）\*\*ため、同じ5msステップでシミュレーションすることも現実的です。したがって本報告のPython実装例では基本的に5ms間隔でモータ状態とEKFを同期させて更新する構造とし、必要に応じて内部サブステップを挟めるようにクラス構成を工夫します。例えばMotorModel内で内部時間解像度を持たせ、高速サンプリングした結果を出力する仕組みも考えられますが、まずは単純化して進めます。

## Pythonによるシミュレーション構成例

ここではPythonベースでシステム全体をシミュレーションする際のクラス設計、データフロー、可視化の工夫について解説します。オブジェクト指向的にモデルを組むことで、モータの真値モデルとEKFによる推定モデルを分離し、見通しの良いシミュレーションを行います。

### クラス設計と役割分担

**1. モータモデルクラス (`MotorModel`):**
モータの物理モデルを表すクラスです。内部に真値のパラメータと状態（\$i\_d, i\_q\$など）を持ち、与えられた入力\$V\_d, V\_q, \omega\$に対して電流応答を計算します。このクラスには温度に応じたパラメータ補正の機能も組み込みます。主要なメンバとメソッド例は以下の通りです。

* メンバ変数: `id`（d軸電流）, `iq`（q軸電流）, `Rs`（抵抗）, `L`（インダクタンス）, `psi_f`（磁束）, `temperature`（現在温度）
* メソッド: `update_params(temp)` – 引数の温度に基づき内部の`Rs, L, psi_f`を更新する。
* メソッド: `step(vd, vq, omega, dt)` – 時間刻みdtだけモータの状態を進める。現在の`Rs, L, psi_f`値を使い微分方程式をdt積分し、`id, iq`を更新する。戻り値として新しい`id, iq`を返す。

**2. EKFクラス (`MotorEKF`など):**
EKFアルゴリズムを実装するクラスです。こちらは推定する状態を保持し、MotorModelとは独立にモデルを内部でもっています（推定用モデルのパラメータは当然推定値に依存）。主要な設計は以下です。

* メンバ変数: `x_hat`（状態推定ベクトル、例: NumPy配列で長さ5）, `P`（推定誤差共分散行列）, 各種行列`Q, R, F, H`（プロセスノイズ共分散、観測ノイズ共分散、ヤコビアン更新用など）
* メソッド: `predict(vd, vq, omega, dt)` – 入力を使って状態を時間更新（予測）する。内部的に現在の\$x\_hat\$から上記\$f(x,u)\$を適用して次時刻の\$x\_hat\$を計算し、併せてF行列を計算して\$P\$を更新する。
* メソッド: `update(meas_id, meas_iq)` – 観測値（電流）を使って状態を測定更新する。残差を計算しカルマンゲインで\$x\_hat, P\$を修正する。

**3. 温度プロファイル提供:**
温度\$T(t)\$の変化はあらかじめシナリオに沿って決めておきます。例えば「初期20°Cから徐々に80°Cまで線形上昇する」や「ある時点で急に温度上昇する」など、関数またはテーブルで与えます。実装上は、単純な関数`T(t)`としておき、シミュレーションループ内で現在時刻に応じて呼び出します。クラスにするほどではないですが、構造を明確にするため別途定義しておくと良いでしょう。

**4. その他（コントローラの出力するVd,Vq指令）:**
本設定では\$V\_d, V\_q\$指令は一定またはあらかじめ決めた波形を入力とします。したがってシミュレーションでは単純に定数や周期的波形を与えるだけで良く、専用クラスは不要です。例えば\$V\_d=0\$、\$V\_q\$にある一定値を与えトルク指令相当の電流を流す等、目的に合わせ決めておきます。

以下に、上記クラスのコードスケルトンを示します（Python擬似コード形式）：

```python
import numpy as np

class MotorModel:
    def __init__(self, Rs0, L0, psi0, id0=0.0, iq0=0.0):
        # 初期パラメータと状態をセット
        self.Rs = Rs0
        self.L = L0
        self.psi_f = psi0
        self.id = id0
        self.iq = iq0

    def update_params(self, temperature):
        """温度に応じてRs, L, psi_fを更新"""
        # ここで例えば線形補間や式によりパラメータ計算
        self.Rs, self.L, self.psi_f = get_params_from_temp(temperature)

    def step(self, vd, vq, omega, dt):
        """オイラー法で電流をdt秒だけ進める"""
        # 微分方程式の右辺計算（Ld=Lq=Lを仮定）
        did_dt = (1.0/self.L) * (vd - self.Rs * self.id + omega * self.L * self.iq)
        diq_dt = (1.0/self.L) * (vq - self.Rs * self.iq - omega * (self.L * self.id + self.psi_f))
        # オイラー積分で状態更新
        self.id += did_dt * dt
        self.iq += diq_dt * dt
        return self.id, self.iq


class MotorEKF:
    def __init__(self):
        # 状態ベクトル x = [id, iq, Rs, L, psi_f]
        self.x_hat = np.zeros(5)  
        # 初期推定値の設定（必要ならid,iqは0、パラメータは公称値で初期化）
        # 例えば:
        # self.x_hat[:] = [0.0, 0.0, Rs_initial, L_initial, psi_initial]
        self.P = np.eye(5) * 0.1  # 初期共分散（適当に小さな不確かさから開始）
        # プロセスノイズ共分散 Q の設定
        self.Q = np.diag([1e-5, 1e-5, 1e-7, 1e-7, 1e-7])
        # 観測ノイズ共分散 R の設定（電流センサノイズの分散）
        self.R = np.diag([1e-4, 1e-4])
        # 観測行列 H の定義
        self.H = np.array([[1, 0, 0, 0, 0],
                            [0, 1, 0, 0, 0]], dtype=float)

    def predict(self, vd, vq, omega, dt):
        """EKF予測ステップ: 状態予測と共分散更新"""
        # 状態変数の読み出し
        id_hat, iq_hat, Rs_hat, L_hat, psi_hat = self.x_hat
        # モデル予測計算（オイラー法で更新）
        did_dt = (1.0/L_hat) * (vd - Rs_hat * id_hat + omega * L_hat * iq_hat)
        diq_dt = (1.0/L_hat) * (vq - Rs_hat * iq_hat - omega * (L_hat * id_hat + psi_hat))
        id_hat_new = id_hat + did_dt * dt
        iq_hat_new = iq_hat + diq_dt * dt
        # パラメータは推定モデル上変化しない（今回はそのまま保持。微小ノイズで変動する想定）
        Rs_hat_new  = Rs_hat
        L_hat_new   = L_hat
        psi_hat_new = psi_hat
        # 状態予測更新
        self.x_hat = np.array([id_hat_new, iq_hat_new, Rs_hat_new, L_hat_new, psi_hat_new])
        # ヤコビアンFを計算（線形化）
        # ... F計算処理（省略：上で述べた偏微分に基づき計算）
        F = compute_jacobian(id_hat, iq_hat, Rs_hat, L_hat, psi_hat, vd, vq, omega)
        # 共分散予測
        self.P = F.dot(self.P).dot(F.T) + self.Q

    def update(self, meas_id, meas_iq):
        """EKF更新ステップ: 観測に基づき状態修正"""
        # イノベーション（観測残差）
        z = np.array([meas_id, meas_iq])
        y = z - self.H.dot(self.x_hat)  # 予測出力との差
        # カルマンゲイン計算
        S = self.H.dot(self.P).dot(self.H.T) + self.R  # 残差の共分散
        K = self.P.dot(self.H.T).dot(np.linalg.inv(S))
        # 状態更新
        self.x_hat = self.x_hat + K.dot(y)
        # 共分散更新
        I = np.eye(len(self.x_hat))
        self.P = (I - K.dot(self.H)).dot(self.P)
        # 推定結果を返す（必要に応じて）
        return self.x_hat
```

上記のコードスケルトンでは、モータモデルとEKFそれぞれの基本的な処理を定義しています。`MotorModel.step`では単純な前進オイラー法で電流を更新し、`MotorEKF.predict`では推定状態に対して同様にモデルを適用しています。`MotorEKF.update`では電流計測値と予測値の差を取り、カルマンフィルタの式に従って推定を補正しています。実際の実装では`compute_jacobian`関数内でヤコビアン\$F\$を計算する必要があります（偏微分のプログラム実装を行うか、あるいは自動微分ライブラリを用いることも可能です）。

### シミュレーションループとデータフロー

クラスが準備できたら、次にシステム全体を回すシミュレーションループを構築します。流れとしては以下のようになります。

1. **初期設定:** 時間ステップ\$\Delta t\$、総シミュレーション時間、初期温度、モータの初期パラメータ真値、EKFの初期推定値などを定め、`MotorModel`と`MotorEKF`のインスタンスを生成します。また、入力となる\$V\_d, V\_q, \omega\$の値（もしくは時間変化）を決定します。例えば\$V\_d=0, V\_q=\text{定数}\$（一定トルク指令相当）、\$\omega\$は定速運転値とします。温度プロファイルも例えば`T(t) = 20 + 0.01 * t [°C]`のような単調増加を用意します。

2. **シミュレーションループ（逐次時間更新）:**
   時刻\$t=0\$から最終時刻まで、\$\Delta t\$刻みで以下を繰り返します。

   * **温度更新:** 現在時刻の温度\$T(t)\$を取得し、`MotorModel.update_params(T)`を呼んでモータ真値モデルの\$R\_s, L, \psi\_f\$を更新します。このとき**EKF内の推定値には温度の直接情報は与えません**（EKFは電流の挙動から間接的に推定します）。
   * **モータモデルのステップ実行:** `MotorModel.step(vd, vq, omega, dt)`を呼び、真のモータの電流応答を計算します。これにより次時刻の真の\$i\_d, i\_q\$（シミュレーション上の“観測される電流”）が得られます。
   * **EKF予測ステップ:** 同じ入力\$vd, vq, \omega, dt\$を用いて、`EKF.predict(vd, vq, omega, dt)`を呼び出し、状態推定を前方予測します。この時点での\$\hat{i}\_d, \hat{i}\_q\$やパラメータ推定\$\hat{R}\_s, \hat{L}, \hat{\psi}\_f\$が更新されます。
   * **EKF更新ステップ:** \$\Delta t\$経過後のタイミングで観測が得られるので、`EKF.update(meas_id, meas_iq)`を呼び出します。ここで`meas_id, meas_iq`はモータモデルから得た真値電流に、必要ならばセンサノイズを加えて用います（シミュレーションなのでノイズ無しでも良いですが、現実性を見るなら微小な乱れを加えることもあります）。この更新により\$\hat{R}\_s, \hat{L}, \hat{\psi}\_f\$が観測に基づき修正されます。なお、EKFの観測は5msごとですが、仮に内部でより短い積分ステップを用いる場合は、観測が無いステップでは`EKF.predict`のみを複数回行い、観測があるステップで`update`を行うよう組みます。ここでは簡単のため毎ステップ観測が得られる前提（5msごとに全て実行）で示します。
   * **データ記録:** 各時刻で、真値のパラメータ（MotorModel内の\$R\_s, L, \psi\_f\$）と推定値（EKFの\$\hat{R}\_s, \hat{L}, \hat{\psi}\_f\$）、真値電流と推定電流、温度などを保存します。Pythonではリストにappendするか、NumPy配列に代入していく形で保持します。後でグラフ化するため、時系列データとして蓄積します。

   上記ループを実装した簡単なコード例を示します。

   ```python
   # 初期化
   total_time = 5.0        # 総シミュレーション時間 [秒]
   dt = 0.005              # 刻み時間 5ms
   steps = int(total_time / dt)
   motor = MotorModel(Rs0=0.5, L0=0.01, psi0=0.1)       # 初期パラメータ
   ekf   = MotorEKF()
   # 初期EKF推定値をモータ公称値で設定
   ekf.x_hat = np.array([0.0, 0.0, 0.5, 0.01, 0.1])     # id=0, iq=0, Rs=0.5, L=0.01, psi=0.1

   # 入力指令の設定（例: Vqに定格の一定電圧を印加し、Vd=0、速度一定）
   vd_cmd = 0.0
   vq_cmd = 5.0          # 例えば5V程度の印加 (適当に設定)
   omega_profile = lambda t: 100.0                     # 例えば定速100 [rad/s] （約955rpm）
   temp_profile  = lambda t: 20.0 + 40.0 * (t/5.0)     # 20°Cから5秒間で60°C上昇

   # データ保存用リスト
   t_history = []
   temp_history = []
   Rs_true_hist, L_true_hist, psi_true_hist = [], [], []
   Rs_est_hist,  L_est_hist,  psi_est_hist  = [], [], []
   id_hist, iq_hist = [], []
   id_est_hist, iq_est_hist = [], []

   # シミュレーションループ
   current_time = 0.0
   for k in range(steps):
       # 真の温度とパラメータ更新
       T = temp_profile(current_time)
       motor.update_params(T)
       # モータモデルをステップ実行
       id_true, iq_true = motor.step(vd_cmd, vq_cmd, omega_profile(current_time), dt)
       # EKF予測と更新
       ekf.predict(vd_cmd, vq_cmd, omega_profile(current_time), dt)
       ekf.update(id_true, iq_true)  # ノイズ無し観測を使用（適宜ノイズ追加可能）
       # データ記録
       t_history.append(current_time)
       temp_history.append(T)
       Rs_true_hist.append(motor.Rs);    L_true_hist.append(motor.L);    psi_true_hist.append(motor.psi_f)
       Rs_est_hist.append(ekf.x_hat[2]); L_est_hist.append(ekf.x_hat[3]); psi_est_hist.append(ekf.x_hat[4])
       id_hist.append(id_true); iq_hist.append(iq_true)
       id_est_hist.append(ekf.x_hat[0]); iq_est_hist.append(ekf.x_hat[1])
       # 時刻更新
       current_time += dt
   ```

   このループにより、時間の進行に沿ってモータの真値モデルとEKF推定器が絡み合って動作します。**データフロー**としては、\$V\_d,V\_q,\omega\$という同じ入力が真値モータとEKF内モデルに与えられ、モータから出た電流（真値観測）がEKFにフィードバックされるという構造になっています。これをブロック図で表せば、真値系（システム）と推定器（オブザーバ）が並列に存在し、システムの出力を用いてオブザーバの状態を補正する、という典型的な**オブザーバ構造**です。その中でEKFはパラメータまで含めて推定している点が通常の状態オブザーバと異なる点です。

   **異なる周期への対応:** 先述のとおり、もしモータ内部でさらに小ステップ積分が必要なら、上記ループ内で例えば1ms刻みのサブステップをさらに回すこともできます。その場合`motor.step`と`ekf.predict`を複数回呼び出し、最後に`ekf.update`を1回行うような入れ子ループ構造にします。シンプルさを優先するなら上記のままでも十分動作するでしょう。

### シミュレーション結果の可視化と分析

シミュレーション終了後、記録したデータを使って結果を評価します。Pythonでは`matplotlib`などを用いてグラフ化することで、EKFがパラメータ変動をどの程度追従できているかを直観的に確認できます。**可視化のポイント**としては次のようなものがあります。

* **パラメータ推定履歴:** 真値の\$R\_s, L, \psi\_f\$とEKF推定値\$\hat{R}\_s, \hat{L}, \hat{\psi}\_f\$を同一グラフ上にプロットします。時間を横軸に、縦軸に各パラメータの値を取り、真値を実線、推定値を点線やマーカー付き線で示すと良いでしょう。これにより、温度変化に応じた真値パラメータ曲線に対し、EKF推定がどのように追従しているかがわかります。理想的にはEKF推定値が遅れを持ちながらも真値に漸近し、温度上昇に伴う緩やかな変化をしっかりトレースしていることが確認できるはずです。もし大きなずれが生じる場合は、EKFのパラメータノイズ\$Q\$を調整する必要があるかもしれません。

* **電流波形:** \$i\_d, i\_q\$の時間応答を描画します。特にステップ応答や定常状態の変化を見ることで、パラメータ変化による電流の変化が観察できます。例えば抵抗\$R\_s\$が上がると同じ電圧でも電流の定常値が下がる、磁束\$\psi\_f\$が減少すると\$q\$軸電流（トルク電流）に変化が出る、といった影響が現れるでしょう。EKFの推定した\$i\_d, i\_q\$（すなわち\$\hat{x}\$の第1,2成分）もプロットし、真値と重ねて比較します。EKF推定電流と実電流がしっかり一致していれば、状態推定がうまくいっている証拠となります。

* **温度プロファイル:** 上記パラメータグラフに温度の推移も重ねて表示すると、温度上昇に伴うパラメータ変動の関連が見やすくなります。例えば第二軸（右目盛り）に温度\[°C]をとって折れ線で示し、左目盛りには抵抗値などを表示する方法があります。

具体的なグラフ作成コードは以下のようになります（matplotlibの利用例）：

```python
import matplotlib.pyplot as plt

# パラメータ推定結果の描画
plt.figure(figsize=(8,5))
plt.subplot(311)
plt.plot(t_history, Rs_true_hist, label='Rs True')
plt.plot(t_history, Rs_est_hist, '--', label='Rs Estimated')
plt.ylabel("Rs [Ω]")
plt.legend(loc='best')
plt.subplot(312)
plt.plot(t_history, L_true_hist, label='L True')
plt.plot(t_history, L_est_hist, '--', label='L Estimated')
plt.ylabel("L [H]")
plt.legend(loc='best')
plt.subplot(313)
plt.plot(t_history, psi_true_hist, label='Psi_f True')
plt.plot(t_history, psi_est_hist, '--', label='Psi_f Estimated')
plt.ylabel("Psi_f [Wb]")
plt.xlabel("Time [s]")
plt.legend(loc='best')
plt.show()

# 電流波形の描画
plt.figure(figsize=(8,4))
plt.plot(t_history, id_hist, label='i_d True')
plt.plot(t_history, id_est_hist, '--', label='i_d EKF')
plt.plot(t_history, iq_hist, label='i_q True')
plt.plot(t_history, iq_est_hist, '--', label='i_q EKF')
plt.xlabel("Time [s]")
plt.ylabel("Current [A]")
plt.legend(loc='best')
plt.show()
```

このコードにより、パラメータ3種について真値と推定値の比較グラフ、および電流について真値と推定値の比較グラフが得られます。**結果の読み取り:** 例えば抵抗\$R\_s\$では温度上昇に伴いゆっくりと値が増加していき、それに追随してEKF推定値（破線）も上昇していく様子が見えるでしょう。同様に\$\psi\_f\$は減少し、推定値もそれに倣うはずです。インダクタンス\$L\$の変化は微小なので、推定値はほぼ一定で真値と区別が難しいかもしれませんが、誤差範囲内で推移することが期待されます。電流波形では、例えば\$q\$軸電流が最初ある定常値から徐々に低下していれば、それは磁束低下や抵抗増加により同じ電圧では電流が減る現象かもしれません。EKFが正しく機能していれば、推定した電流（オブザーバによる推定値）も実測電流にぴたりと重なり、両者の差はノイズ程度のごく小さなものになるでしょう。

## まとめ

温度変化に伴うモータパラメータの変動を取り入れ、拡張カルマンフィルタでその値を推定するシミュレーション構成について、要件に沿って整理しました。温度→パラメータ変換テーブルは典型的な材料の温度係数から設計でき、EKFにおいてはパラメータを状態量に含めることでオンライン推定を実現します。異なる更新周期の問題も、モータモデルの内部ステップとEKFの予測・更新を工夫して組み合わせることで対処可能です。Pythonによる実装では、モータモデルとEKFをクラス分離し、分かりやすいデータフローでシミュレーションできるように構築しました。コードスケルトンおよび疑似コードを示したように、設計者はこの構成を基に詳細なチューニング（例えばEKFの\$Q,R\$調整や温度プロファイルの多様化）を行い、パラメータ推定性能を評価できます。今回の例では、抵抗や磁束といったパラメータの推定値が温度変化に追従する様子をプロットで確認できるでしょう。今後、より高精度なモデル（例えば磁気飽和や回転子温度による影響も含む）や他の推定手法との比較を行うことで、モータ制御系のロバスト性向上に繋げられると考えられます。
