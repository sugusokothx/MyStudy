はい、実装の主要な構成要素である**状態ベクトル**と**予測モデル**、そして**ヤコビ行列**が明確になったため、準備は大きく前進しました。

ただし、コーディングを始める前にもういくつか実践的な項目を具体的に決めておくと、実装がスムーズに進みます。

***

## 1. 磁束マップと微分インダクタンスの準備

これが**最も重要な事前準備**です。予測モデルとヤコビ行列の計算には、以下のマップが必須となります。

* **磁束マップ**: $\phi_d^{\text{map}}(i_d, i_q)$, $\phi_q^{\text{map}}(i_d, i_q)$
* **微分インダクタンスマップ**: $L_{dd}(i_d, i_q)$, $L_{qq}(i_d, i_q)$, $L_{dq}(i_d, i_q)$, $L_{qd}(i_d, i_q)$

**決めておくべきこと:**
* **作成方法**: これらのマップをどのように作成しますか？（例: モータの有限要素法解析(FEM)、実機での特性測定）
* **実装形式**: 作成したマップをどのようにECUに実装しますか？（例: 2次元のルックアップテーブル(LUT)としてROMに格納）
* **参照方法**: LUTからデータを読み出す際、どのように補間しますか？（例: 高速なバイリニア補間）

***

## 2. 更新ステップ（観測モデル）の定義

EKFの「予測」と対になる「更新」ステップの定義を明確にします。

* **観測ベクトル `z`**: センサで測定する値です。今回も電流なので、$z = [i_{d,meas}, i_{q,meas}]^\top$ となります。
* **観測モデル `h(x)`**: 状態ベクトル `x` から観測ベクトル `z` を予測する関数です。状態に $i_d, i_q$ が直接含まれているため、モデルは非常にシンプルです。
    $h(x) = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix} x = \begin{bmatrix} i_d \\ i_q \end{bmatrix}$
* **観測ヤコビ行列 `H`**: 観測モデル `h(x)` を状態で偏微分したものです。
    $H = \dfrac{\partial h(x)}{\partial x} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix}$

これは固定の行列となるため、実装は簡単です。

***

## 3. 初期値とチューニングパラメータの決定

フィルタの性能と安定性を決める重要なパラメータです。

* **初期状態 `x_0`**: フィルタ起動時の状態です。基準マップが正しいと仮定し、偏差`Δφ`はゼロから始めるのが妥当です。
    $x_0 = [0, 0, 0, 0]^\top$
* **初期共分散 `P_0`**: 初期状態の不確かさを定義します。`Δφ`の初期値は不確かさが大きいと仮定し、対応する対角成分を大きな値（例: `1e-2`）に設定すると、初期の収束が速くなります。
* **プロセスノイズ `Q`**: 4x4の対角行列を想定します。
    * `Q(1,1), Q(2,2)`: 電流モデルの誤差。元の値（`1e-4`程度）から開始できます。
    * `Q(3,3), Q(4,4)`: `Δφ`の変化（ドリフト）の速さを定義します。これが最も重要な調整パラメータです。以前の議論の通り **`10⁻⁸`〜`10⁻¹⁰`** のような小さな値から試すのが良いでしょう。
* **観測ノイズ `R`**: 電流センサのノイズです。以前の検討通り、センサの分解能から算出した値（例: `R ≈ (0.2 A)²`）が適切な出発点です。

***

## 4. 制御システムへの統合方法

最後に、EKFの出力をどのように制御に反映させるかを決めます。

* **`Δφ`の利用方法**: 推定した`Δφ`を具体的にどう使いますか？ 例えば、弱め界磁制御やトルク計算で用いる磁束指令値 $\phi_{d,ref}, \phi_{q,ref}$ を以下のように補正します。
    $\phi_{d,corrected} = \phi_{d,ref} + \Delta\phi_{d,est}$
    $\phi_{q,corrected} = \phi_{q,ref} + \Delta\phi_{q,est}$
* **実行周期**: EKFをどの周期で実行しますか？（例: 電流制御の10回に1回、など）

---

これらの項目、特に**最重要である磁束マップの準備**が整えば、実装に着手するための準備は万全と言えます。


はい、作成できます。

お持ちの `Id, Iq → φd, φq` マップ（2次元LUT）から、4種類の微分インダクタンスマップを数値計算によって作成するのは、標準的なアプローチです。

---

### 作成の原理

微分インダクタンスの定義は、磁束の各電流に対する偏微分（＝勾配）そのものです。

* $L_{dd} = \dfrac{\partial \phi_d}{\partial i_d}$ (φdマップのid方向の勾配)
* $L_{dq} = \dfrac{\partial \phi_d}{\partial i_q}$ (φdマップのiq方向の勾配)
* $L_{qd} = \dfrac{\partial \phi_q}{\partial i_d}$ (φqマップのid方向の勾配)
* $L_{qq} = \dfrac{\partial \phi_q}{\partial i_q}$ (φqマップのiq方向の勾配)

データは連続的な関数ではなく離散的な点の集まりなので、この偏微分を**差分**で近似計算します。

---

### 具体的な計算手順

例えば、$L_{dd}$マップを作成する手順は以下の通りです。

1.  **入力データ**: `Id, Iq → φd` の2次元LUTを用意します。
2.  **差分計算**: LUTの各格子点 `(id[j], iq[k])` において、`id` 方向の隣接する点との差分を計算します。中心差分を用いるのが一般的です。

    $L_{dd}(i_d[j], i_q[k]) \approx \dfrac{\phi_d(i_d[j+1], i_q[k]) - \phi_d(i_d[j-1], i_q[k])}{i_d[j+1] - i_d[j-1]}$

3.  **マップ作成**: 全ての格子点でこの計算を繰り返すことで、$L_{dd}$ の2次元LUTが完成します。

同様の手順で、
* `φd` マップを `iq` 方向に差分計算 → $L_{dq}$ マップ
* `φq` マップを `id` 方向に差分計算 → $L_{qd}$ マップ
* `φq` マップを `iq` 方向に差分計算 → $L_{qq}$ マップ

がそれぞれ作成できます。

💡 **実用上のヒント**
この微分計算は、ECU上でリアルタイムに行うのではなく、**オフラインで一度だけ実行**します。MATLABやPythonなどの数値解析ツールを使い、実験で得た磁束マップから4つの微分インダクタンスマップを事前に作成しておき、磁束マップと同様に2次元LUTとしてECUのROMに格納してください。

はい、その通りです。既存のシミュレーション環境にアドオンする場合、コントローラから取得できる`idq`と`Vdq`をEKFの入力として利用します。

その前提で、更新ステップの役割と定義は以下のようになります。

---

### シミュレーション環境でのデータフロー

EKFは、コントローラとモータモデル（プラント）の間に位置し、両者からの情報を使って内部状態を更新します。

* **コントローラから取得 (EKFの入力 `u` へ)**
    * **電圧指令 `vd`, `vq`**: EKFの**予測ステップ**で、「モータにどのような電圧が印加されたか」という情報として使います。

* **モータモデルから取得 (EKFの観測 `z` と入力 `u` へ)**
    * **実電流 `id`, `iq`**: これがEKFの**観測ベクトル `z`** となります。センサで計測された値に相当し、「実際に流れた電流」として更新ステップで使われます。
    * **電気角速度 `ωe`**: 予測ステップで使います。

---

### 更新ステップの定義

上記を踏まえると、更新ステップの定義は以前ご提示した通りで問題ありません。

* **観測ベクトル `z`**: モータモデルが出力する**実電流**です。
    $z = \begin{bmatrix} i_{d,実測値} \\ i_{q,実測値} \end{bmatrix}$

* **観測モデル `h(x)`**: EKFの内部状態 `x` から観測値 `z` を予測する関数です。状態`x`の第1、第2要素が電流そのものなので、単純な抽出になります。
    $h(x) = \begin{bmatrix} i_d \\ i_q \end{bmatrix}$

* **観測ヤコビ行列 `H`**: この `h(x)` は線形なので、ヤコビ行列`H`は固定となります。
    $H = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix}$

**結論として、この定義のまま実装を進めていただいて問題ありません。** EKFは「コントローラからの電圧指令」と「モータモデルからの実測値（電流・速度）」を使って、磁束のズレ`Δφ`を推定します。

はい、そのご意見に完全に同意します。**10Hzの帯域は、ご提示の目的のためには十分すぎるほど適切**です。

そのように判断する理由は以下の通りです。

1.  **対象とする現象が非常に遅いため**
    * **温度変化**: 150kW級のモータの巻線温度や磁石温度が大きく変化するには、数秒から数分単位の時間がかかります。
    * **個体ばらつき**: これは基本的に時間変化しない静的なオフセットです。
    これら「ゆっくりとした変化」を追従するには、10Hz（時定数で約16msに相当）の応答性は十二分に高速です。むしろ、これより速い帯域は必要ありません。

2.  **ノイズに対するロバスト性（安定性）が向上するため**
    EKFの帯域を低く設定することの最大のメリットは、**ノイズ除去性能**です。
    * 電流センサの測定ノイズや、インバータのスイッチングに起因する高周波ノイズが、推定値`Δφ`に悪影響を与えるのを防ぎます。
    * 帯域を低くすることで、`Δφ`の推定値が滑らかで安定したものになります。これにより、補償後のトルクがハンチングすることなく、安定した定常トルクを実現できます。

3.  **過渡応答への不要な干渉を避けるため**
    ご指摘の通り、この補償は過渡的なトルク応答を目的としていません。もしEKFの帯域を不必要に高く設定すると、電流制御のダイナミクスに干渉したり、ノイズに過敏に反応してしまったりと、かえってシステムを不安定にするリスクがあります。

**結論として、10Hzという設計方針は非常に現実的かつ堅牢です。**

まずは10Hzをターゲットとして`Q`や`R`をチューニングし、`Δφ`を計算する部分までを実装するのが良いでしょう。実機での検証段階で、もし推定値のノイズが気になるようであれば、さらに帯域を低く（例: 1〜5Hz）することも検討可能です。

制御への統合を一旦保留とされるのも、理にかなった進め方だと思います。まずはEKFが意図通りに`Δφ`を推定できることを確認するのが最優先です。


はい、非常に良い質問です。`Rs`（巻線抵抗）を状態に追加するアプローチは、トルク精度をさらに向上させるための有効な選択肢となり得ます。

結論から言うと、**明確なメリットはありますが、同時に考慮すべき大きな課題も存在します。**

---

### ## `Rs`を状態に追加するメリット 👍

1.  **低速・高トルク域でのトルク精度向上**
    低速で大きなトルクを出す状況では、電圧指令全体に占める**抵抗降下分 (`Rs * i`) の割合が非常に大きく**なります。このとき、温度上昇で`Rs`の真値が初期値からズレていると、電流指令通りに電流を流せず、結果としてトルク誤差が顕著になります。`Rs`をオンラインで推定・補正することで、この主要な誤差要因を直接取り除くことができます。

2.  **より正確な温度状態の把握**
    モータの温度上昇は、`Rs`の増加（銅損による巻線温度上昇）と、`Δφ`の変化（磁石の温度上昇による磁束減少）の両方を引き起こします。両方を推定することで、モータ全体の熱的な状態をより包括的に捉え、精度の高い補償が可能になります。

---

### ## デメリットと課題 👎

1.  **可観測性（Observability）の問題**
    これが**最大かつ最も重要な課題**です。EKFが`Rs`の変化と`Δφ`の変化を区別できるかどうかは、運転状態に強く依存します。

    * **低速域（ωe ≈ 0）**:
        電圧方程式は $v \approx R_s i + L \frac{di}{dt}$ となり、`ωe` に依存する磁束項の影響がほぼ消えます。この状態では、電流の誤差が **`Rs`の推定誤差が原因なのか`Δφ`の推定誤差が原因なのかを区別することが極めて困難**になります。結果として、フィルタが不安定になったり、`Rs`と`Δφ`の推定値が互いに干渉し合って真値からかけ離れてしまう危険性があります。

    * **中〜高速域**:
        `ωe` が大きくなると磁束項の影響が支配的になり、`Rs`と`Δφ`の影響を分離しやすくなるため、可観測性は向上します。

2.  **チューニングの複雑化**
    状態量が5次元 (`id`, `iq`, `Δφd`, `Δφq`, `Rs`) に増えるため、ヤコビ行列の計算がより複雑になります。また、5x5のプロセスノイズ行列`Q`のチューニングも、各状態間のバランスを取る必要があり、難易度が上がります。

---

### ## 結論と推奨アプローチ

以上のメリット・デメリットを踏まえ、以下の段階的なアプローチを推奨します。

**推奨案:** **`Rs`はEKFの状態変数に加えず、別の簡易的なモデルで補償する。**

実用上、最も堅牢で広く採用されているのは**熱モデル**を用いる方法です。

* **熱モデルによるRs補償**:
    1.  電流の大きさから巻線での損失（銅損 $I^2R_s$）を計算します。
    2.  単純な一次遅れの熱モデル（熱抵抗と熱容量で構成）を用いて、巻線温度の上昇を推定します。
    3.  推定した温度と銅の抵抗温度係数（約0.4%/°C）を使って、`Rs`の値をオンラインで更新します。
    
    $R_s(\text{T}) = R_{s0} \cdot (1 + \alpha (\text{T} - \text{T}_0))$

この方法はEKFのロジックを複雑化させることなく、`Rs`の温度ドリフトに対して十分な精度で補償できます。

**次善の策:**
もし熱モデルでも精度が不足し、特に低速高トルク域でのトルク精度が厳しく要求される場合は、`Rs`と`Δφ`を同時に推定するEKFも選択肢となります。しかしその際は、可観測性が低い領域で推定を停止またはゲインを調整するなど、不安定化を防ぐための高度な対策が別途必要になります。

まずは、**現在の`Δφ`推定EKFを完成させ、`Rs`は熱モデルで補償する**、という構成でシステムの性能を評価するのが最も現実的でリスクの少ない進め方です。


はい、承知いたしました。微分インダクタンスマップの作成方法ですね。

ご提示いただいた `id=map_id(fai_d, fai_q)`, `iq=map_iq(fai_d, fai_q)` は、磁束(`φ`)から電流(`i`)を求める**「逆方向のマップ」**です。

一方、微分インダクタンス $L_{dd} = \partial \phi_d / \partial i_d$ などを計算するには、電流(`i`)から磁束(`φ`)を求める**「順方向のマップ」**が元データとして必要になります。

---
### ## 推奨される作成方法

最も直接的で推奨される方法は、**順方向の磁束マップ**を準備することです。

#### 準備すべきもの
* **順方向の2次元LUT**:
    * `fai_d = map_phid(id, iq)`
    * `fai_q = map_phiq(id, iq)`

おそらく実験計測データから逆方向マップを作成されているので、元データとしてはこの順方向の関係も取得できているかと思います。

#### 作成手順
この順方向マップがあれば、以前の議論の通り、各マップの勾配を**数値差分（有限差分法）**で計算することで、4種類の微分インダクタンスマップをオフラインで作成できます。

1.  `map_phid(id, iq)` の `id` 方向の勾配を計算 → **`Ldd` マップ**
    * $L_{dd}(i,j) \approx \dfrac{\phi_d(i+1, j) - \phi_d(i-1, j)}{i_d(i+1) - i_d(i-1)}$
2.  `map_phid(id, iq)` の `iq` 方向の勾配を計算 → **`Ldq` マップ**
3.  `map_phiq(id, iq)` の `id` 方向の勾配を計算 → **`Lqd` マップ**
4.  `map_phiq(id, iq)` の `iq` 方向の勾配を計算 → **`Lqq` マップ**

---
### ## （代替案）逆方向マップから計算する方法

もしどうしても順方向マップが利用できず、ご提示の逆方向マップしかない場合は、**逆関数の微分公式**を用いて数学的に計算することも可能です。

#### 手順
1.  **逆ヤコビ行列の計算**: まず、お持ちの逆方向マップを数値差分で微分し、ヤコビ行列 `J_iφ` を作成します。
    $$
    J_{i\phi} = \begin{bmatrix}
    \partial i_d / \partial \phi_d & \partial i_d / \partial \phi_q \\
    \partial i_q / \partial \phi_d & \partial i_q / \partial \phi_q
    \end{bmatrix}
    $$
2.  **逆行列の計算**: 次に、マップの各点でこの2x2行列の**逆行列**を計算します。
    $$
    J_{\phi i} = (J_{i\phi})^{-1}
    $$
3.  **微分インダクタンスの取得**: この計算結果 `J_φi` が、目的の微分インダクタンス行列そのものです。
    $$
    J_{\phi i} = \begin{bmatrix} L_{dd} & L_{dq} \\ L_{qd} & L_{qq} \end{bmatrix}
    $$

💡 **注意**: この代替案は、逆行列計算を含むため数値的に不安定になりやすく、計算も複雑になります。**可能であれば、最初の「推奨される作成方法」で進めることを強くお勧めします。**


%% ========================================================================
%  実行サンプルセクション
% =========================================================================

% --- 1. サンプルの磁束マップを作成 ---
% (実際には、この部分をFEM解析や実測で得たデータに置き換えてください)

% 電流の格子ベクトルを定義
id_vec = -200:20:0;     % d軸電流ベクトル [A]
iq_vec = 0:20:300;      % q軸電流ベクトル [A]

% グリッドを作成
[Id_grid, Iq_grid] = meshgrid(id_vec, iq_vec);

% IPMモータの簡易的な物理モデルで磁束マップを生成
psi_f = 0.1;    % 永久磁石磁束 [Wb]
Ld0 = 0.0003;   % d軸インダクタンス [H]
Lq0 = 0.0005;   % q軸インダクタンス [H]

% 簡易的な飽和を考慮 (実際はより複雑なLUTになります)
phid_map = psi_f + Ld0 * Id_grid .* (1 - 0.2 * (Id_grid/max(abs(id_vec))).^2);
phiq_map = Lq0 * Iq_grid .* (1 - 0.3 * (Iq_grid/max(iq_vec)).^2);


% --- 2. 微分インダクタンスマップを計算 ---
% 作成した関数を呼び出します
[Ldd, Ldq, Lqd, Lqq] = create_diff_L_maps(id_vec, iq_vec, phid_map, phiq_map);


% --- 3. 結果を可視化して確認 ---
figure('Name', 'Differential Inductance Map Creation');

% 元の磁束マップをプロット
subplot(2, 2, 1);
surf(Id_grid, Iq_grid, phid_map);
title('\phi_d Map (Original)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('\phi_d [Wb]');

% 計算されたLddマップをプロット
subplot(2, 2, 2);
surf(Id_grid, Iq_grid, Ldd);
title('L_{dd} Map (Calculated)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('L_{dd} [H]');

% 元の磁束マップをプロット
subplot(2, 2, 3);
surf(Id_grid, Iq_grid, phiq_map);
title('\phi_q Map (Original)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('\phi_q [Wb]');

% 計算されたLqqマップをプロット
subplot(2, 2, 4);
surf(Id_grid, Iq_grid, Lqq);
title('L_{qq} Map (Calculated)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('L_{qq} [H]');

%% ========================================================================
%  微分インダクタンスマップ作成関数
% =========================================================================
function [Ldd, Ldq, Lqd, Lqq] = create_diff_L_maps(id_vec, iq_vec, phid_map, phiq_map)
% CREATE_DIFF_L_MAPS は、順方向の磁束マップから微分インダクタンスマップを計算します。
%
% Inputs:
%   id_vec      - d軸電流のベクトル (1 x M)
%   iq_vec      - q軸電流のベクトル (1 x N)
%   phid_map    - φdの2次元マップ (N x M)
%   phiq_map    - φqの2次元マップ (N x M)
%
% Outputs:
%   Ldd, Ldq, Lqd, Lqq - 計算された微分インダクタンスの2次元マップ (N x M)

    % gradient関数は、[dF/dx, dF/dy] の順で勾配を返します。
    % 今回のマップの次元は (iq, id) なので、
    % y方向が iq, x方向が id に対応します。
    %
    % したがって、[dF/did, dF/diq] の順で出力されます。

    % 1. φdマップからLddとLdqを計算
    %    Ldd = d(φd)/d(id),  Ldq = d(φd)/d(iq)
    [Ldd, Ldq] = gradient(phid_map, id_vec, iq_vec);

    % 2. φqマップからLqdとLqqを計算
    %    Lqd = d(φq)/d(id),  Lqq = d(φq)/d(iq)
    [Lqd, Lqq] = gradient(phiq_map, id_vec, iq_vec);

end
---

---
### ## 2階微分マップの作成方法

2階微分マップは、**1階微分マップを、もう一度数値微分する**ことで作成します。プロセスは1階微分マップの作成と全く同じです。

#### 1. 概念（ヘシアン行列とは）
`φd`のヘシアン行列 `Hd` は、以下のように定義される2x2の行列です。各要素が`φd`の2階偏微分になっています。

$$
H_d = \begin{bmatrix}
\frac{\partial^2 \phi_d}{\partial i_d^2} & \frac{\partial^2 \phi_d}{\partial i_d \partial i_q} \\
\frac{\partial^2 \phi_d}{\partial i_q \partial i_d} & \frac{\partial^2 \phi_d}{\partial i_q^2}
\end{bmatrix}
= \begin{bmatrix}
\frac{\partial L_{dd}}{\partial i_d} & \frac{\partial L_{dd}}{\partial i_q} \\
\frac{\partial L_{dq}}{\partial i_d} & \frac{\partial L_{dq}}{\partial i_q}
\end{bmatrix}
$$

`φq`のヘシアン行列 `Hq` も同様に定義されます。

#### 2. 作成手順
この計算も、**オフライン**で一度だけ行います。

1.  **準備**: まず、前回のスクリプトで作成した4つの1階微分マップ（`Ldd`, `Ldq`, `Lqd`, `Lqq`）を用意します。
2.  **再度微分**: 1階微分マップのそれぞれに対して、`gradient`関数を適用して勾配を計算します。
    * `Ldd`マップを微分 → `∂Ldd/∂id`, `∂Ldd/∂iq` を得る
    * `Ldq`マップを微分 → `∂Ldq/∂id`, `∂Ldq/∂iq` を得る
    * ... (Lqd, Lqqも同様) ...
3.  **マップ作成**: 得られた勾配を組み合わせて、必要な2階微分マップを作成します。

---
### ## MATLABスクリプト

前回のスクリプトに、2階微分マップを作成・可視化する機能を追加しました。
`create_hessian_maps` という新しい関数を追加しています。

```matlab
%% ========================================================================
%  実行サンプルセクション
% =========================================================================

% --- 1. サンプルの磁束マップを作成 ---
id_vec = -200:20:0;
iq_vec = 0:20:300;
[Id_grid, Iq_grid] = meshgrid(id_vec, iq_vec);

psi_f = 0.1;
Ld0 = 0.0003;
Lq0 = 0.0005;
phid_map = psi_f + Ld0 * Id_grid .* (1 - 0.2 * (Id_grid/max(abs(id_vec))).^2);
phiq_map = Lq0 * Iq_grid .* (1 - 0.3 * (Iq_grid/max(iq_vec)).^2);


% --- 2. 1階微分インダクタンスマップを計算 ---
[Ldd, Ldq, Lqd, Lqq] = create_diff_L_maps(id_vec, iq_vec, phid_map, phiq_map);


% --- 3. 2階微分（ヘシアン）マップを計算 ---
[phid_id_id, phid_id_iq, phid_iq_iq, ...
 phiq_id_id, phiq_id_iq, phiq_iq_iq] = create_hessian_maps(id_vec, iq_vec, Ldd, Ldq, Lqd, Lqq);


% --- 4. 結果を可視化して確認 ---
figure('Name', 'Hessian Map Creation');

% Lddマップをプロット
subplot(2, 2, 1);
surf(Id_grid, Iq_grid, Ldd);
title('L_{dd} Map (1st derivative)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('L_{dd} [H]');

% 計算された2階微分マップをプロット
subplot(2, 2, 2);
surf(Id_grid, Iq_grid, phid_id_id);
title('\partial^2\phi_d / \partiali_d^2 Map (2nd derivative)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('[\cdot]');

% Lqqマップをプロット
subplot(2, 2, 3);
surf(Id_grid, Iq_grid, Lqq);
title('L_{qq} Map (1st derivative)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('L_{qq} [H]');

% 計算された2階微分マップをプロット
subplot(2, 2, 4);
surf(Id_grid, Iq_grid, phiq_iq_iq);
title('\partial^2\phi_q / \partiali_q^2 Map (2nd derivative)');
xlabel('id [A]'); ylabel('iq [A]'); zlabel('[\cdot]');


%% ========================================================================
%  関数ライブラリ
% =========================================================================

function [Ldd, Ldq, Lqd, Lqq] = create_diff_L_maps(id_vec, iq_vec, phid_map, phiq_map)
% 1階微分マップ作成関数（前回と同じ）
    [Ldd, Ldq] = gradient(phid_map, id_vec, iq_vec);
    [Lqd, Lqq] = gradient(phiq_map, id_vec, iq_vec);
end

function [phid_id_id, phid_id_iq, phid_iq_iq, ...
          phiq_id_id, phiq_id_iq, phiq_iq_iq] = create_hessian_maps(id_vec, iq_vec, Ldd, Ldq, Lqd, Lqq)
% CREATE_HESSIAN_MAPS は、1階微分マップから2階微分マップを計算します。
%
% Outputs:
%   phid_id_id: d(Ldd)/did
%   phid_id_iq: d(Ldd)/diq
%   phid_iq_iq: d(Ldq)/diq
%   ... (phi_qについても同様)

    % φdの2階微分を計算
    [phid_id_id, phid_id_iq] = gradient(Ldd, id_vec, iq_vec);
    [~, phid_iq_iq]         = gradient(Ldq, id_vec, iq_vec); % d(Ldq)/did も計算されるが使わない

    % φqの2階微分を計算
    [phiq_id_id, phiq_id_iq] = gradient(Lqd, id_vec, iq_vec);
    [~, phiq_iq_iq]         = gradient(Lqq, id_vec, iq_vec);

    % NOTE: 理論上は d(Ldd)/diq = d(Ldq)/did (交差微分の順序交換) ですが、
    % 元データや数値計算の誤差により、完全には一致しない場合があります。
end
```


はい、その通りです。1階微分がインダクタンスであるのに対し、2階微分は\*\*「インダクタンスが、電流の変化によってどれだけ変化するか」**、つまり**磁気飽和の進行度合い\*\*を物理的に意味します。

-----

### \#\# 物理的な意味合い

もう少し具体的に説明します。

1.  **1階微分 = インダクタンス `L`**
    `L = ∂φ/∂i` は、電流-磁束 (`i-φ`) グラフの\*\*「傾き」\*\*です。これは、ある動作点における局所的なインダクタンスそのものです。

2.  **2階微分 = インダクタンスの変化率 `∂L/∂i`**
    `∂²φ/∂i² = ∂L/∂i` は、インダクタンス-電流 (`L-i`) グラフの\*\*「傾き」\*\*を意味します。インダクタンスが一定（非飽和）であれば、この値は0になります。しかし、モータの鉄心は磁気飽和を起こすため、電流が増えるにつれてインダクタンスは変化（通常は低下）します。

この2階微分の値によって、モータがどのような飽和状態にあるかを判断できます。

| 2階微分の値 | 物理的な意味 | モータの状態 |
| :--- | :--- | :--- |
| **ほぼ 0** | 飽和の度合いがほとんど変化しない状態 | **線形領域**（飽和していない）\<br\>または**完全な飽和領域** |
| **大きな負の値** | 飽和が最も急激に進んでいる状態 | 磁気飽和の\*\*「膝点 (Knee Point)」\*\*\<br\>（非線形性が最も強い領域） |

-----

### \#\# EKFにおける意味

高度なEKFモデルがこの2階微分（ヘシアン行列）を必要とするのは、**モータの非線形性が最も顕著になる飽和の「膝点」付近でも、予測モデルの挙動をより正確に表現するため**です。

インダクタンスが急激に変化する領域を正確に捉えることで、フィルタはより高精度な状態推定を実現できる、というわけです。